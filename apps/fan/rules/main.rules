# Main rule file

object PolyhedralComplex {

   property CONTRACTIBLE : Bool;

   rule CONTRACTIBLE : HOMOLOGY {
      my $homology = $this->HOMOLOGY;
      foreach my $gp (@$homology){
         if($gp->betti_number > 0){
            $this->CONTRACTIBLE = 0;
            return;
         }
      }
      $this->CONTRACTIBLE = 1;
   }

}

user_function isInImmaculatePosition(Polytope, Polytope){
   my($P, $Q) = @_;
   # Returns true if P\Q is non-empty and contractible
   if (isContained($P,$Q)){
      return 0;
   }
   my $testComplex = setminusComplex($P,$Q);
   return $testComplex->CONTRACTIBLE;
}

user_function findPolytopeOfRelevantShifts(Polytope, Polytope){
   my($P, $Q) = @_;
   # Finds the shifts such that P\(u+Q) != P
   # The polytope of relevant shifts is equal to -P+Q.
   my $mP = scale_wrap($P, -1);
   return minkowski_sum($mP,$Q);
}

sub setminusComplex{
   my($P,$Q) = @_;
   # Creates a polyhedral complex out of P and deletes every face that intersects
   # Q nonempty
   my @faces = ();
   my $vertP = $P->VERTICES;
   foreach my $face (@{$P->HASSE_DIAGRAM->FACES}){
      if($face->size > 0){
         my $honestFace = new Polytope(POINTS=>$vertP->minor($face, All));
         my $check = intersection($Q, $honestFace);
         if(!$check->FEASIBLE){
            push @faces, $face;
         }
      }
   }
   my $testComplex = new PolyhedralComplex(POINTS=>$vertP, INPUT_POLYTOPES=>\@faces);
   return $testComplex;
}

sub shiftByVector{
   # Shifts Q by vector v;
   my($v, $Q) = @_;
   my $Pv = new Polytope(POINTS=>[$v]);
   return minkowski_sum($Pv, $Q);
}

user_function isImmaculatePair(Polytope, Polytope){
   my($P, $Q) = @_;
   my $shifts = findPolytopeOfRelevantShifts($Q, $P);
   $shifts = $shifts->LATTICE_POINTS;
   foreach my $shift (@$shifts){
      my $check = isInImmaculatePosition($P, shiftByVector($shift, $Q));
      if(!$check){
         return 0;
      }
   }
   return 1;
}

user_function isContained(Polytope, Polytope){
   my($P,$Q) = @_;
   my $vert = $P->VERTICES;
   foreach my $v (@$vert){ 
      if(!($Q->contains($v))){
         return 0;
      }
   }
   return 1;
}

user_function immaculacyMatrix(Polytope, Polytope, $ , $ ){
   my ($P,$Q,$a,$b) = @_;
   # Checks if the pairs aP and bQ are immaculate
   my $result = new Matrix($a,$b);
   my %qs;
   for (my $j =0; $j <$b; $j++){
      $qs{$j} = scale_wrap($Q, $j);
   }
   for (my $i=0; $i < $a; $i++){
      my $Pi = scale_wrap($P, $i);
      for (my $j =0; $j <$b; $j++){
         $result->elem($i,$j)=isImmaculatePair($Pi,$qs{$j});
      }
   }
   return $result;
}

sub scale_wrap{
   my($P, $i) = @_;
   if($i == 0){
      return new Polytope(POINTS=>[ones_vector(1)|zero_vector($P->DIM)]);
   } else {
      return scale($P, $i);
   }
}

####################################
# New approach from Klaus

user_function intersection_approach(Array<Set<Int> >, Matrix){
   my($A, $M) = @_;
   my @cones = map(build_cone_pair($_, $M), @$A);
   @cones = map((new Polytope(POINTS=>$_)), @cones);
   print "Building cones ok.\n";
   build_components_recursively(@cones);
}

sub build_components_recursively{
   my @cones = @_;
   if(@cones == 1){
      my $cone = pop @cones;
      print "Done with inner.\n";
      my @result = get_clean_antifacets_list($cone);
      return map(new Matrix([$_]), @result);
   } else {
      my $cone = pop @cones;
      print "Popped.\n";
      my @preres = build_components_recursively(@cones);
      my @newFacets = get_clean_antifacets_list($cone);
      print "Got list.\n";
      my @result;
      foreach my $facet (@newFacets){
         foreach my $matrix (@preres){
            my $toadd = new Matrix($matrix / $facet);
            $toadd = simplify_gens($toadd);
            push @result, $toadd;
         }
      }
      if(@result > 100){
         print "Size is: ", scalar @result, "\n";
         my $R = new Set<Matrix<Rational> >(@result);
         @result = @$R;
         print "Reduced to ", scalar @result, "\n";
      }
         # print "Checking.\n";
         # @result = grep((new Polytope(INEQUALITIES=>$_))->FEASIBLE, @result);
         # print "Reduced to ", scalar @result, "\n";
      return @result;
   }
}

sub simplify_gens{
   my($mat) = @_;
   my $gens = new Set<Vector<Rational> >(@$mat);
   return new Matrix(sort @$gens);
}

sub get_clean_antifacets_list{
   my($cone) = @_;
   my $facets = new Matrix<Rational>(primitive($cone->FACETS));
   my $ezero = unit_vector<Rational>($facets->cols, 0);
   $facets = - new Matrix(grep($_ != $ezero, @$facets));
   my $newFacets = ($facets->minor(All, [0]) - ones_matrix($facets->rows, 1)) | $facets->minor(All, ~[0]);
   return @$newFacets;
}

sub build_cone_pair {
   my ($index, $M) = @_;
   my $entire = new Set<Int>(0..($M->rows - 1));
   my $comp = $entire - $index;
   my $A = build_cone_from_index_set($index, $M);
   my $B = build_cone_from_index_set($comp, $M);
   return($A, $B);
}

sub build_cone_from_index_set{
   my ($index, $M) = @_;
   my $negative = - $M->minor($index, All);
   my $positive = $M->minor(~$index, All);
   my $root = transpose($negative) * ones_vector($negative->rows);
   my $gens = new Matrix(zero_vector | $negative);
   $gens /= zero_vector | $positive;
   $gens /= ones_vector(1) | $root;
   return $gens;
}

