# Main rule file

object PolyhedralComplex {

   property CONTRACTIBLE : Bool;

   rule CONTRACTIBLE : HOMOLOGY {
      my $homology = $this->HOMOLOGY;
      foreach my $gp (@$homology){
         if($gp->betti_number > 0){
            $this->CONTRACTIBLE = 0;
            return;
         }
      }
      $this->CONTRACTIBLE = 1;
   }

}

user_function isInImmaculatePosition(Polytope, Polytope){
   my($P, $Q) = @_;
   # Returns true if P\Q is non-empty and contractible
   if (isContained($P,$Q)){
      return 0;
   }
   my $testComplex = setminusComplex($P,$Q);
   return $testComplex->CONTRACTIBLE;
}

user_function findRelevantShifts(Polytope, Polytope){
   my($P, $Q) = @_;
   # Finds the shifts such that P\(u+Q) != P
   # The polytope of relevant shifts is equal to -P+Q.
   my $A = (-1)*($P->VERTICES)->minor(All,~[0]);
   $A = ones_vector($A->rows) | $A;
   my $mP = new Polytope(POINTS=>$A);
   return minkowski_sum($mP,$Q)->LATTICE_POINTS;
}

sub setminusComplex{
   my($P,$Q) = @_;
   # Creates a polyhedral complex out of P and deletes every face that intersects
   # Q nonempty
   my @faces = ();
   my $vertP = $P->VERTICES;
   foreach my $face (@{$P->HASSE_DIAGRAM->FACES}){
      if($face->size > 0){
         my $honestFace = new Polytope(POINTS=>$vertP->minor($face, All));
         my $check = intersection($Q, $honestFace);
         if(!$check->FEASIBLE){
            push @faces, $face;
         }
      }
   }
   my $testComplex = new PolyhedralComplex(POINTS=>$vertP, INPUT_POLYTOPES=>\@faces);
   return $testComplex;
}

sub shiftByVector{
   # Shifts Q by vector v;
   my($v, $Q) = @_;
   my $Pv = new Polytope(POINTS=>[$v]);
   return minkowski_sum($Pv, $Q);
}

user_function isImmaculatePair(Polytope, Polytope){
   my($P, $Q) = @_;
   my $shifts = findRelevantShifts($Q, $P);
   foreach my $shift (@$shifts){
      my $check = isInImmaculatePosition($P, shiftByVector($shift, $Q));
      if(!$check){
         return 0;
      }
   }
   return 1;
}

user_function isContained(Polytope, Polytope){
   my($P,$Q) = @_;
   my $vert = $P->VERTICES;
   foreach my $v (@$vert){ 
      if(!($Q->contains($v))){
         return 0;
      }
   }
   return 1;
}
