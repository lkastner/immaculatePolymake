# Main rule file

object PolyhedralComplex {

   property CONTRACTIBLE : Bool;

   rule CONTRACTIBLE : HOMOLOGY {
      # TODO
      $this->CONTRACTIBLE = True;
   }

}

user_function isInImmaculatePosition(Polytope, Polytope){
   my($P, $Q) = @_;
   # Returns true if P\Q is non-empty and contractible
   if (isContained($P,$Q){
      return False;
   }
   my $testComplex = setminuscomplex($P,$Q);
   if($testComplex->CONTRACTIBLE){
      return True;
   }
   return False;
}

user_function findRelevantShifts(Polytope, Polytope){
   my($P, $Q) = @_;
   # Finds the shifts such that P\(u+Q) != P
   my $A = -*$P->VERTICES;
   # TODO: Make the first column of a 11111 again
   my $mP = new Polytope(POINTS=>$A);
   return minkowski_sum($mP,$Q);
}

sub setminuscomplex{
   my($P,$Q) = @_;
   # Creates a polyhedral complex out of P and deletes every face that intersects
   # Q nonempty
   my $testComplex = new PolyhedralComplex(check_fan_objects(new Cone($P)));
}

sub shiftByVector{
   # Shifts Q by vector v;
   my($v, $Q) = @_;
   my $Pv = new Polytope(POINTS=>[$v]);
   return minkowski_sum($Pv, $Q);
}

user_function isImmaculatePair(Polytope, Polytope){
   my($P, $Q) = @_;
   my @shifts = findRelevantShifts($P, $Q);
   foreach my $shift (@shifts){
      if(!isInImmaculatePosition($P, shiftByVector($shift, $Q))){
         return False;
      }
   }
   return True;
}

user_function isContained(Polytope, Polytope){
   my($P,$Q) = @_;
   my $PintQ
}
