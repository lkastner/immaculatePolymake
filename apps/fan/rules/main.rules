# Main rule file

object PolyhedralComplex {

   property CONTRACTIBLE : Bool;

   rule CONTRACTIBLE : HOMOLOGY {
      my $homology = $this->HOMOLOGY;
      foreach my $gp (@$homology){
         if($gp->betti_number > 0){
            $this->CONTRACTIBLE = 0;
            return;
         }
      }
      $this->CONTRACTIBLE = 1;
   }

}

user_function isInImmaculatePosition(Polytope, Polytope){
   my($P, $Q) = @_;
   # Returns true if P\Q is non-empty and contractible
   if (isContained($P,$Q)){
      return 0;
   }
   my $testComplex = setminusComplex($P,$Q);
   return $testComplex->CONTRACTIBLE;
}

user_function findPolytopeOfRelevantShifts(Polytope, Polytope){
   my($P, $Q) = @_;
   # Finds the shifts such that P\(u+Q) != P
   # The polytope of relevant shifts is equal to -P+Q.
   my $mP = scale_wrap($P, -1);
   return minkowski_sum($mP,$Q);
}

sub setminusComplex{
   my($P,$Q) = @_;
   # Creates a polyhedral complex out of P and deletes every face that intersects
   # Q nonempty
   my @faces = ();
   my $vertP = $P->VERTICES;
   foreach my $face (@{$P->HASSE_DIAGRAM->FACES}){
      if($face->size > 0){
         my $honestFace = new Polytope(POINTS=>$vertP->minor($face, All));
         my $check = intersection($Q, $honestFace);
         if(!$check->FEASIBLE){
            push @faces, $face;
         }
      }
   }
   my $testComplex = new PolyhedralComplex(POINTS=>$vertP, INPUT_POLYTOPES=>\@faces);
   return $testComplex;
}

sub shiftByVector{
   # Shifts Q by vector v;
   my($v, $Q) = @_;
   my $Pv = new Polytope(POINTS=>[$v]);
   return minkowski_sum($Pv, $Q);
}

user_function isImmaculatePair(Polytope, Polytope){
   my($P, $Q) = @_;
   my $shifts = findPolytopeOfRelevantShifts($Q, $P);
   $shifts = $shifts->LATTICE_POINTS;
   foreach my $shift (@$shifts){
      my $check = isInImmaculatePosition($P, shiftByVector($shift, $Q));
      if(!$check){
         return 0;
      }
   }
   return 1;
}

user_function isContained(Polytope, Polytope){
   my($P,$Q) = @_;
   my $vert = $P->VERTICES;
   foreach my $v (@$vert){ 
      if(!($Q->contains($v))){
         return 0;
      }
   }
   return 1;
}

user_function immaculacyMatrix(Polytope, Polytope, $ , $ ){
   my ($P,$Q,$a,$b) = @_;
   # Checks if the pairs aP and bQ are immaculate
   my $result = new Matrix($a,$b);
   my %qs;
   for (my $j =0; $j <$b; $j++){
      $qs{$j} = scale_wrap($Q, $j);
   }
   for (my $i=0; $i < $a; $i++){
      my $Pi = scale_wrap($P, $i);
      for (my $j =0; $j <$b; $j++){
         $result->elem($i,$j)=isImmaculatePair($Pi,$qs{$j});
      }
   }
   return $result;
}

sub scale_wrap{
   my($P, $i) = @_;
   if($i == 0){
      return new Polytope(POINTS=>[ones_vector(1)|zero_vector($P->DIM)]);
   } else {
      return scale($P, $i);
   }
}

