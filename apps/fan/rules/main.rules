# Main rule file

object PolyhedralComplex {

   property CONTRACTIBLE : Bool;

   rule CONTRACTIBLE : HOMOLOGY {
      my $homology = $this->HOMOLOGY;
      foreach my $gp (@$homology){
         if($gp->betti_number > 0){
            $this->CONTRACTIBLE = 0;
            return;
         }
      }
      $this->CONTRACTIBLE = 1;
   }

}

user_function isInImmaculatePosition(Polytope, Polytope){
   my($P, $Q) = @_;
   # Returns true if P\Q is non-empty and contractible
   if (isContained($P,$Q)){
      return 0;
   }
   my $testComplex = setminusComplex($P,$Q);
   return $testComplex->CONTRACTIBLE;
}

user_function findPolytopeOfRelevantShifts(Polytope, Polytope){
   my($P, $Q) = @_;
   # Finds the shifts such that P\(u+Q) != P
   # The polytope of relevant shifts is equal to -P+Q.
   my $mP = scale_wrap($P, -1);
   return minkowski_sum($mP,$Q);
}

sub setminusComplex{
   my($P,$Q) = @_;
   # Creates a polyhedral complex out of P and deletes every face that intersects
   # Q nonempty
   my @faces = ();
   my $vertP = $P->VERTICES;
   foreach my $face (@{$P->HASSE_DIAGRAM->FACES}){
      if($face->size > 0){
         my $honestFace = new Polytope(POINTS=>$vertP->minor($face, All));
         my $check = intersection($Q, $honestFace);
         if(!$check->FEASIBLE){
            push @faces, $face;
         }
      }
   }
   my $testComplex = new PolyhedralComplex(POINTS=>$vertP, INPUT_POLYTOPES=>\@faces);
   return $testComplex;
}

sub shiftByVector{
   # Shifts Q by vector v;
   my($v, $Q) = @_;
   my $Pv = new Polytope(POINTS=>[$v]);
   return minkowski_sum($Pv, $Q);
}

user_function isImmaculatePair(Polytope, Polytope){
   my($P, $Q) = @_;
   my $shifts = findPolytopeOfRelevantShifts($Q, $P);
   $shifts = $shifts->LATTICE_POINTS;
   foreach my $shift (@$shifts){
      my $check = isInImmaculatePosition($P, shiftByVector($shift, $Q));
      if(!$check){
         return 0;
      }
   }
   return 1;
}

user_function isContained(Polytope, Polytope){
   my($P,$Q) = @_;
   my $vert = $P->VERTICES;
   foreach my $v (@$vert){ 
      if(!($Q->contains($v))){
         return 0;
      }
   }
   return 1;
}

user_function immaculacyMatrix(Polytope, Polytope, $ , $ ){
   my ($P,$Q,$a,$b) = @_;
   # Checks if the pairs aP and bQ are immaculate
   my $result = new Matrix($a,$b);
   my %qs;
   for (my $j =0; $j <$b; $j++){
      $qs{$j} = scale_wrap($Q, $j);
   }
   for (my $i=0; $i < $a; $i++){
      my $Pi = scale_wrap($P, $i);
      for (my $j =0; $j <$b; $j++){
         $result->elem($i,$j)=isImmaculatePair($Pi,$qs{$j});
      }
   }
   return $result;
}

sub scale_wrap{
   my($P, $i) = @_;
   if($i == 0){
      return new Polytope(POINTS=>[ones_vector(1)|zero_vector($P->DIM)]);
   } else {
      return scale($P, $i);
   }
}

####################################
# New approach from Klaus

user_function find_maculates(PolyhedralFan){
   my($pf) = @_;
   my @result = find_nonfaces($pf);
   push @result, new Set<Int>([0..$pf->N_RAYS-1]);
	@result = grep{
		my $s = $_;
		my $subfan = select_subfan($pf, $s);
		if(has_homology($subfan)){
			push @result, $s;
		}
	} @result;
	push @result, new Set<Int>([]);
   return @result;
}

sub find_nonfaces{
   my($fan) = @_;
	my @result = ();
   my $all = new Set<Int>([0..$fan->N_RAYS-1]);
	for(my $k = 1; $k<=$fan->N_RAYS; $k++){
		my @subsets = all_subsets_of_k($k, 0..($fan->N_RAYS-1));
		@subsets = map((new Set<Int>($_)), @subsets);
		foreach my $s (@subsets){
			my $comp = $all-$s;
			my $check = 1;
			foreach my $face (@{$fan->HASSE_DIAGRAM->FACES}){
				if($s == $face){
					$check = 0;
					last;
				}
				if($comp == $face){
					$check = 0;
					last;
				}
			}
			if($check){
				push @result, $s;
			}
		}
	}
	return @result;
}

sub select_subfan{
   my($fan, $s) = @_;
   my @result = ();
   my @faces = @{$fan->HASSE_DIAGRAM->FACES};
   foreach my $face (@faces){
      my $intersection = $face * $s;
      if($intersection->size == $face->size){
         push @result, $face;
      }
   }
   if(@result > 0){
      return new PolyhedralFan(INPUT_RAYS=>$fan->RAYS, INPUT_CONES=>\@result);
   } else {
      return new PolyhedralFan(INPUT_RAYS=>$fan->RAYS, INPUT_CONES=>[[]]);
   }
}

sub has_homology{
   my($fan) = @_;
   if($fan->N_MAXIMAL_CONES == 0){
      return 1;
   }
   my @homology = @{$fan->HOMOLOGY};
   foreach my $gp (@homology){
      if($gp->[1] != 0){
         return 1;
      }
   }
   return 0;
}

user_function intersection_approach(Array<Set<Int> >, Matrix){
   my($A, $M) = @_;
   my @cones = map(build_cone_from_index_set($_, $M), @$A);
   @cones = map((new Polytope(POINTS=>$_)), @cones);
   print "Building cones ok.\n";
   my @result = build_components_recursively(@cones);
   print "Size after building intersections: ",scalar @result,"\n";
   @result = map((new Set<Vector<Rational> >(@$_)), @result);
   @result = find_inclusion_minimals(@result);
   print "Inclusion minimal facet combinations: ",scalar @result,"\n";
   print join("\n\n", @result);
   @result = map(new Matrix(@$_), @result);
   @result = map(new Polytope(INEQUALITIES=>$_), @result);
   return inclusion_maximal_polyhedra(@result);
   return @result;
}

sub inclusion_maximal_polyhedra {
   my @polytopes = @_;
   my @result = ();
   while(@polytopes > 0){
      my $current = pop @polytopes;
      my $containers = 0;
      for my $p (@result, @polytopes){
         if(included_polyhedra($current, $p)){
            $containers = 1;
            last;
         }
      }
      if($containers == 0){
         push @result, $current;
      }
   }
   return @result;
}

sub find_inclusion_minimals {
   my @sets = @_;
   my @result = ();
   while(@sets > 0){
      my $current = pop @sets;
      my $id = grep{
         my $intersection = $current * $_;
         $_->size == $intersection->size
      } @result,@sets;
      if($id == 0){
         push @result, $current;
      }
   }
   return @result;
}

sub build_components_recursively{
   my @cones = @_;
   if(@cones == 1){
      my $cone = pop @cones;
      my @result = get_clean_antifacets_list($cone);
      return map(new Matrix([$_]), @result);
   } else {
      my $cone = pop @cones;
      my @preres = build_components_recursively(@cones);
      if($cone->LINEALITY_DIM == $cone->DIM){
         # If the cone is everything, there will be no facets, so intersecting
         # does nothing.
         return @preres;
      }
      my @newFacets = get_clean_antifacets_list($cone);
      my @result;
      foreach my $facet (@newFacets){
         foreach my $matrix (@preres){
            my $toadd = new Matrix($matrix / $facet);
            $toadd = simplify_gens($toadd);
            push @result, $toadd;
         }
      }
      # # The following two ifs should just reduce the amount of matrices we are
      # # stuck with, otherwise we never finish.
      if(@result > 100){
         my $R = new Set<Matrix<Rational> >(@result);
         @result = @$R;
      }
      # if(@result > 10){
        print "Reducing polyhedra, ",scalar @result, "\n";
        @result = map(new Polytope(INEQUALITIES=>$_), @result);
        @result = inclusion_maximal_polyhedra(@result);
        @result = map($_->INEQUALITIES, @result);
        print "Reducing done, ",scalar @result, "\n";
      # }
      return @result;
   }
}

sub simplify_gens{
   my($mat) = @_;
   my $gens = new Set<Vector<Rational> >(@$mat);
   return new Matrix(sort @$gens);
}

sub get_clean_antifacets_list{
   my($cone) = @_;
   if($cone->LINEALITY_DIM > 0){
      print "Should check lineality dim now!\n";
   }
   my $facets = new Matrix<Rational>(primitive($cone->FACETS));
   if(!$cone->FULL_DIM){
      print "Should check full dim now!\n";
      my $aff = new Matrix<Rational>(primitive($cone->AFFINE_HULL));
      $facets = $facets / $aff / -$aff;
   }
   print "Facets: ",$facets->rows,"\n";
   my $ezero = unit_vector<Rational>($facets->cols, 0);
   $facets = new Matrix(grep($_ != $ezero, @$facets));
   $facets = - new Matrix($facets);
   my $newFacets = ($facets->minor(All, [0]) - ones_matrix($facets->rows, 1)) | $facets->minor(All, ~[0]);
   return @$newFacets;
}

sub build_cone_pair {
   my ($index, $M) = @_;
   my $entire = new Set<Int>(0..($M->rows - 1));
   my $comp = $entire - $index;
   my $A = build_cone_from_index_set($index, $M);
   my $B = build_cone_from_index_set($comp, $M);
   return($A, $B);
}

sub build_cone_from_index_set{
   my ($index, $M) = @_;
   my $negative = - $M->minor($index, All);
   my $positive = $M->minor(~$index, All);
   my $root = transpose($negative) * ones_vector($negative->rows);
   my $gens = new Matrix(zero_vector | $negative);
   $gens /= zero_vector | $positive;
   $gens /= ones_vector(1) | $root;
   return $gens;
}

