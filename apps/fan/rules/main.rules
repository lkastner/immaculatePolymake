# Main rule file

object PolyhedralComplex {

   property CONTRACTIBLE : Bool;

   rule CONTRACTIBLE : HOMOLOGY {
      # TODO
      $this->CONTRACTIBLE = True;
   }

}

user_function isInImmaculatePosition(Polytope, Polytope){
   my($P, $Q) = @_;
   # Returns true if P\Q is non-empty and contractible
   if (isContained($P,$Q){
      return False;
   }
   my $testComplex = setminusComplex($P,$Q);
   if($testComplex->CONTRACTIBLE){
      return True;
   }
   return False;
}

user_function findRelevantShifts(Polytope, Polytope){
   my($P, $Q) = @_;
   # Finds the shifts such that P\(u+Q) != P
   # The polytope of relevant shifts is equal to -P+Q.
   my $A = (-1)*($P->VERTICES)->minor(All,~[0]);
   $A = ones_vector($A->rows) | $A;
   my $mP = new Polytope(POINTS=>$A);
   return minkowski_sum($mP,$Q);
}

sub setminusComplex{
   my($P,$Q) = @_;
   # Creates a polyhedral complex out of P and deletes every face that intersects
   # Q nonempty
   my $testComplex = new PolyhedralComplex(check_fan_objects(new Cone($P)));
   # TODO walk through faces and delete them
   return $testComplex;
}

sub shiftByVector{
   # Shifts Q by vector v;
   my($v, $Q) = @_;
   my $Pv = new Polytope(POINTS=>[$v]);
   return minkowski_sum($Pv, $Q);
}

user_function isImmaculatePair(Polytope, Polytope){
   my($P, $Q) = @_;
   my @shifts = findRelevantShifts($P, $Q);
   foreach my $shift (@shifts){
      if(!isInImmaculatePosition($P, shiftByVector($shift, $Q))){
         return False;
      }
   }
   return True;
}

user_function isContained(Polytope, Polytope){
   my($P,$Q) = @_;
   my $PintQ = intersection($P,$Q);
   # Since asking for the Vertices to be equal did not work as expected
   # I check whether the intersection has as many lattice points as the 
   # polytope we started with. This method will not (always) give the right 
   # result if the polytopes are not lattice polytopes.
   if($P->N_LATTICE_POINTS==$PintQ->N_LATTICE_POINTS){
      return True;
   }
   return False;
}
