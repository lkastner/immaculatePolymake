object TDivisor {

   property IMMACULATE : Bool;

}

object NormalToricVariety {

   user_method decompose_into_nef_pair(TDivisor){
      my ($this, $d) = @_;
      my ($v1, $v2) = internal_decompose_into_nef($this->RATIONAL_DIVISOR_CLASS_GROUP->PROJECTION, $this->RATIONAL_DIVISOR_CLASS_GROUP->LIFTING, $this->NEF_CONE->FACETS, $d->COEFFICIENTS);
      
      # Construct actual nef divisors, assign to toric variety.
      my $div1 = $this->DIVISOR(COEFFICIENTS=>$v1);
      my $div2 = $this->DIVISOR(COEFFICIENTS=>$v2);
      return ($div1, $div2);
   }

   rule DIVISOR.IMMACULATE : DIVISOR.COEFFICIENTS, NEF_CONE, RATIONAL_DIVISOR_CLASS_GROUP.PROJECTION, RATIONAL_DIVISOR_CLASS_GROUP.LIFTING {
      # Get coefficients
      my ($v1, $v2) = internal_decompose_into_nef($this->RATIONAL_DIVISOR_CLASS_GROUP->PROJECTION, $this->RATIONAL_DIVISOR_CLASS_GROUP->LIFTING, $this->NEF_CONE->FACETS, $this->DIVISOR->COEFFICIENTS);
      # Little workaround, since computing properties of the divisors is forbidden.
      my $div1 = $this->DIVISOR(COEFFICIENTS=>$v1, temporary);
      my $div2 = $this->DIVISOR(COEFFICIENTS=>$v2, temporary);
      $this->DIVISOR->IMMACULATE = is_immaculate_pair($div1->SECTION_POLYTOPE, $div2->SECTION_POLYTOPE);
   }

}

sub internal_decompose_into_nef {
   my($projection, $lifting, $nefFacets, $coeffs) = @_;
   # Decompose divisor into two nef divisors:
   # Project to class (Picard) group
   my $pi = transpose($projection);
   my $pv = $pi * $coeffs;
   my $n = $pv->dim;
   # Construct polytope of all ($pv1, $pv2) with
   # - $pv1, $pv2 nef
   # - $pv1 - $pv2 = $coeffs
   my $B = (-$pv) | unit_matrix($n) | -unit_matrix($n);
   $B = dense($B);
   my $AA = zero_vector(2*$nefFacets->rows) | ($nefFacets / zero_matrix($nefFacets->rows, $nefFacets->cols));
   my $AAA = $AA | (zero_matrix($nefFacets->rows, $nefFacets->cols) / $nefFacets);
   my $P = new Polytope(INEQUALITIES=>$AAA, EQUATIONS=>$B);
   # Extract one solution
   my $pvv = new Vector<Rational>($P->LATTICE_POINTS_GENERATORS->[0]->[0]);
   my $pv1 = $pvv->slice(range(1,$pv->dim));
   my $pv2 = $pvv->slice(range(1+$pv->dim, 2*$pv->dim));
   # Lift $pv1 and $pv2 to Weil divisor group
   my $lift = transpose($lifting);
   my $v1 = $lift * $pv1;
   my $v2 = $lift * $pv2;
   return ($v1, $v2);
}

# @category Producing a normal toric variety
# Produces a smooth normal toric variety of Picard rank 2 with the Kleinschmidt construction.
# @param Int d The dimension (equal to number of rays - 2).
# @param Vector<Int> a The Kleinschmidt parameters.
# @return NormalToricVariety
user_function kleinschmidt( Int , Vector<Int> ) {
   # The variable names are chosen according to the Kleinschmidt construction in:
   #
   # Peter Kleinschmidt. A classification of toric varieties with few generators.
   # Aequationes Math., 35(2-3):254â€“266, 1988.
   my($d, $aInt) = @_;
   my $a = new Vector<Rational>($aInt);
   $d > 0 or die("Expected a positive integer d.");
   my $r = $a->dim();
   my $s = $d - $r + 1;
   my $Urays = (unit_matrix($r) | -ones_matrix($r,1))/zero_matrix($s-1,$r+1);
   my $vs = $a | (-ones_vector($s-1));
   my $Vrays = (zero_matrix($r,$s-1) / unit_matrix($s-1)) | $vs;
   my $groundSet = new Set<Int>(0..($r+$s));
   my @mc = ();
   for(my $i=0; $i<$r+1; $i++){
      for(my $j=$r+1; $j<=$r+$s; $j++){
         push @mc, $groundSet - $i - $j;
      }
   }
   my $rays = new Matrix($Urays | $Vrays);
   return new NormalToricVariety(INPUT_RAYS=>transpose($rays), INPUT_CONES=>\@mc);
}

