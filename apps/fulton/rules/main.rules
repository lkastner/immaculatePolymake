object TDivisor {

   property IMMACULATE : Bool;

}

object NormalToricVariety {

   rule DIVISOR.IMMACULATE : DIVISOR.COEFFICIENTS, NEF_CONE, RATIONAL_DIVISOR_CLASS_GROUP.PROJECTION, RATIONAL_DIVISOR_CLASS_GROUP.LIFTING {
      # Get coefficients
      my $v = $this->DIVISOR->COEFFICIENTS;

      # Decompose divisor into two nef divisors:
      # Project to class (Picard) group
      my $pi = transpose($this->RATIONAL_DIVISOR_CLASS_GROUP->PROJECTION);
      my $pv = $pi * $v;
      # Construct polytope of all ($pv1, $pv2) with
      # - $pv1, $pv2 nef
      # - $pv1 - $pv2 = $v
      my $nef = $this->NEF_CONE;
      my $A = $nef->FACETS;
      my $B = (-$pv) | unit_matrix(3) | -unit_matrix(3);
      $B = dense($B);
      my $AA = zero_vector(6) | ($A / zero_matrix(3,3));
      my $AAA = $AA | (zero_matrix(3,3) / $A);
      my $P = new Polytope(INEQUALITIES=>$AAA, EQUATIONS=>$B);
      # Extract one solution
      my $pvv = $P->LATTICE_POINTS_GENERATORS->[0]->[0];
      my $pv1 = $pvv->slice(1,$pv->dim);
      my $pv2 = $pvv->slice(1+$pv->dim, $pv->dim);
      # Lift $pv1 and $pv2 to Weil divisor group
      my $lift = transpose($this->RATIONAL_DIVISOR_CLASS_GROUP->LIFTING);
      my $v1 = $lift * $pv1;
      my $v2 = $lift * $pv2;
      
      # Construct actual nef divisors, assign to toric variety temporarily.
      my $div1 = $this->DIVISOR(COEFFICIENTS=>$v1, temporary);
      my $div2 = $this->DIVISOR(COEFFICIENTS=>$v2, temporary);

      $this->DIVISOR->IMMACULATE = isImmaculatePair($div1->SECTION_POLYTOPE, $div2->SECTION_POLYTOPE);
   }

}

# @category Producing a normal toric variety
# Produces a smooth normal toric variety of Picard rank 2 with the Kleinschmidt construction.
# @param Int d The dimension (equal to number of rays - 2).
# @param Vector<Int> a The Kleinschmidt parameters.
# @return NormalToricVariety
user_function kleinschmidt( Int , Vector<Int> ) {
   # The variable names are chosen according to the Kleinschmidt construction in:
   #
   # Peter Kleinschmidt. A classification of toric varieties with few generators.
   # Aequationes Math., 35(2-3):254â€“266, 1988.
   my($d, $aInt) = @_;
   my $a = new Vector<Rational>($aInt);
   $d > 0 or die("Expected a positive integer d.");
   my $r = $a->dim();
   my $s = $d - $r + 1;
   my $Urays = (unit_matrix($r) | -ones_matrix($r,1))/zero_matrix($s-1,$r+1);
   my $vs = $a | (-ones_vector($s-1));
   my $Vrays = (zero_matrix($r,$s-1) / unit_matrix($s-1)) | $vs;
   my $groundSet = new Set<Int>(0..($r+$s));
   my @mc = ();
   for(my $i=0; $i<$r+1; $i++){
      for(my $j=$r+1; $j<=$r+$s; $j++){
         push @mc, $groundSet - $i - $j;
      }
   }
   my $rays = new Matrix($Urays | $Vrays);
   return new NormalToricVariety(INPUT_RAYS=>transpose($rays), INPUT_CONES=>\@mc);
}

